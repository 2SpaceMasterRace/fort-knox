

Languages

    English
    German
    Japanese
    Kannada
    Spanish
    Tamil


Meal Plan: Foundations - Google Sheets
https://docs.google.com/spreadsheets/d/1tc9bhiQDoIKV68JFT7mF7QGbsPt0J26tdUMzJeIQJj4/edit?gid=407572419#gid=407572419
The Art of Manliness | Men's Interests and Lifestyle
https://www.artofmanliness.com/
Fitness Archives | The Art of Manliness
https://www.artofmanliness.com/health-fitness/fitness/
Health Archives | The Art of Manliness
https://www.artofmanliness.com/health-fitness/health/
Program Review Archives | The Art of Manliness
https://www.artofmanliness.com/health-fitness/program-review/
Randumb Fitness - YouTube
https://www.youtube.com/@randumbfitness
Alan Thrall (Untamed Strength) - YouTube
https://www.youtube.com/@AlanThrall






# Career -- TheCMUproject | surviving the real cs nightmare


and the best, employed <1 yr new grad i know has accepted patches to the linux kernel, constantly asked for advice by senior engs, literally the 100x dev so no, it means your performance is just average LOL if you can't even google u are replaceable and have no passion for cs

I am hiring a postdoc at Cornell for systems research on next-generation multi-GPU interconnects. If you are about to graduate with a PhD in CS or a related field, email me at rachee@cs.cornell.edu with your CV and a representative publication.


How you should allocate your time at college 
(in order of importance):

- Internship/Job in relevant field
- Side project
- Looking for better internships & jobs
- Volunteering, Networking, and Clubs
- Classwork & assignments

Be so good you qualify for o1 visa from some top guy like samalt 

[ ]  Take the Python Programming MOOC 2024
[ ]  Do the norvig/pytudes  + watch neetcode videos on python for a quick crash course 
	- Python for Coding Interviews - Everything you need to Know
	- Python for Beginners - Full Course  
[ ]  Craft the perfect OSS Python IDE


## Part 2: Brush up Leetcode and solve as many problems as you can

[ ] Follow the neetcode + blind75xgrind169 roadmap
[ ] Go over the technical interview handbook
[ ] Jane Street software engineering interview blog + yt video
[ ] Try to hack around CollabCodeTech/backend-challenges  
[ ] Watch mock interviews in YouTube 


Projects

Projects listed in vague order of increasing difficulty / time committment. I have not done all these of course, but I at least know someone who did / have some special respect for the creator.
Ray Tracing In One Weekend

Link to Book

This is one of the single most impactful projects I've done! With a raytracer you can model objects in 3D space and generate images for what they'd look like by applying your own colours, angles and lightning. It uses a little bit of math and teaches introductory graphics. The most fun part about raytracing is the development cycle, since you can instantly test software (limited by how fast your computer is) and see the result, without having to worry about hidden bugs.

I estimate for it to take less than a week if you work on it full time and a month if doing it in free time. There is also "Ray Tracing the Next Week" and "Ray Tracing the Rest of Your Life" if you want more!
LLVM Tutorial

Link to Tutorial

The LLVM tutorial helps you to build an entire programming language with LLVM which is insanely fun and relevant to software we use everyday. It also includes teachings about JITs! I recommend not following the OCaml tutorials as the tutorials are old and you'll have trouble installing dependencies (like I did). I really like compilers as an area of focus because unlike graphics or GPU programming, your work is relevant to anyone who is a programmer.

I estimate this to take a week full time and 2+ weeks doing it in free time and no more than two months.
Crafting Interpreters

Link to Book

I put this one after the LLVM tutorial just because it is longer, but Crafting Interpreters is an excellent resource. It actually teaches you how to build two interpreters, one with Java and another with C and also covers VMs and garbage collection. I think the type of interpreters you'll build through Crafting Interpreters will help you understand CRuby and CPython source code more than the LLVM Tutorial will help you understand Rust source code.

I recommend starting on the second interpreter iff you have a solid impression of how interpreters tend to work and you're familiar with programming in C as well as data structures. I estimate the entirety of Crafting Interpreters to take 3 - 6 weeks full time or a few months part time (more variable since it's longer and there are more opportunities to challenge yourself).
Spinning Up in Deep Reinforcement Learning

Link to Resource

This collection of resources / docs is created by Open AI and generally impressed me in quality of documentation (I generally have very little faith in big companies being able to document things well). It's not a tutorial, but is good at giving the full picture (how to get into the career, lingo, example implementations, etc). It also provides two exercises that are fairly long as well as fun information such as PyTorch vs Tensorflow comparisons.

I think of all the resources I listed, this one gets you the closest to a career change (partially just the nature of the ML field). I only list one Machine Learning related resource because other good intro-to-ML guides have good page rank (though I think Spinning Up in Deep RL has underrated pagerank).

Some resources for people who already have some background in AI (read the Wikipedia definitions and did Tensorflow/Pytorch tutorials):

    Deep Dive into Machine Learning (a book)
    For people vaguely familiar with Machine Learning: (language model focused, sorry)
        All You Need is Attention (a paper)
        BERT (a paper, though BERT is not the entire name of the paper)
        GPT2 (also a paper, and GPT2 is not the name of the paper)
    Collection of Resources about AI Safety (doesn't actually need much of a ML background)

Implementing the Raft Distributed Consensus System

Link to Raft Info Page

Raft is a consensus algorithm. I'm not going to describe further, but it's an algorithm to solve problems with distributed systems -- something you may be familiar with! Unlike many of the projects I've listed, Raft will require a lot of reading / research to build background knowledge. Implementing Raft requires knowledge about operating systems, systems programming in general, networks and concurrency. I feel that it'll also test more software engineering skills since the process will include lots of logging, tests and error handling.

I'm not going to give time estimates about Raft since I've read a lot but haven't implemented it. More importantly, it depends on your background. If I had to say, it would be at least a week full time.
Building an Operating System

This one seems fun but I've only briefly attempted it.

Julia Evans on an OS in Rust | Georgia Tech Course Materials | OS Tutorial (unmaintained in 2+ years) | OS Dev Wiki

Though challenging and a long project, I recommend OS dev because it's a surprisingly common project (you can probably find more resources for this than say, Raft). The difficult parts with this project is that it's more open-ended, longer even to get to a minimal project and the development cycle is a bit more painful.

Estimate 4+ weeks full time for a minimal-ish OS.




## Activities and References

### Competitive Programming

Hesistant about including this since it's sometimes just "leetcoding" but I think competitive programming was formative to my programming skills. [Codeforces](https://kipp.ly/past-webdev/codeforces.com/) has weekly contests (also see TopCoder, DMOJ). Some of the problems are more traditional data science and algorithms, but sites like Codeforces over Leetcode will have some more adhoc and math focused puzzles. Speaking of math, [Project Euler](https://projecteuler.net/) is also a great source of problems. I also like throwing away writing good code sometimes and just writing code for me!

### Kaggle for Data Science and Machine Learning

Kaggle is a platform where users receive datasets and try to predict / compute some values in a contest format. They also have some open datasets with various tutorials on how to work with them, such as the [Titanic Dataset](https://www.kaggle.com/c/titanic).

## General Things

### Begone Stack Overflow, Hello Papers

As a web developer, a lot of my learning was throug Stack Overflow, videos and Medium articles. I think my learning of compilers was high-friction because of my unwillingness to read papers (which I'm still working on). This is not applicable to _everything_, for example machine learning has a lot of strong Stack Overflow resources through uses of libraries (though you'll definitely need to read papers for ML), and for learning to do reverse engineering, individual blog posts with write-ups are probably your best resource. In general, you may have to relearn how you filter / search through content.

### Open Source

Something missing from this article is "after I learn these skills, how do I get a job?", and the reason it's missing is because I'd be talking out of my ass if I tried to answer that. However, I do some know reliable ways through which that has been done and Open Source is definitely one of them!

Spend some time looking into different projects and start working up towards contributions. I recommend larger projects for exposure and also because they'll have better support systems for new contributors. I know numerous people who somewhat bypassed education through side projects and gained skills entirely through working on OSS!
Open Source Projects

Decision tree compiler (Ileavcs) c? : An LLVM compiler for trcc-bascd ML models. Speeds up prediction by through cache blocking and profile-guided optimization. Used in production at QuantCo. Sole developer & maintainer, >50K downloads on PyPI. Featured in academic database literature

Tech blog (sibochm.com): 10K monthly visitors. Notable posts: How to Optimize a CUDA Matmul Kernel for cuBLAS-likc Performance  , Can Function Inlining Affect Floating Point Consistency , Pipeline-Parallcl Distributed Training

 Distributed deep learning (ShallowSpeed : Implements distributed training of sequential deep learning models, built on Numpy and MPI. Supports interleaved data parallelism and pipeline parallelism (GPipe). Also see accompanying blog post .

Conditional density estimation (cde) : TensorFlow library implementing ML algorithms for density estimation. Contributed normalizing flows and variational inference. Paper available on ArXiv , >80K downloads on PyPI.


ASRGproject
C-Hacking
 **cpxip-project**
 
fearlessKAISTproject
fullStackOpen
kotlin-experiments
ocaml-street
prjkt-cpp
researchpaper-dump

**riverousrustlang**
summerOfShipping
technicalbooks-dump
tinygobangland
tinymachinelearning
tyrannosaurus-zig


Hari Varsha V is a low-level engineer with a strong focus on performance and machine learning. Previously Summer Intern @ University of California, Santa Cruz ( Go Slugs! ) and now an upcoming grad school student for Fall 2025. He has a special passion in local-first software, realtime databases, multiplayer apps, distributed systems, CRDTs, storage engines and infrastructure. His hobbies include amateur game development, experimenting with Nix and rolling his own config, reading RFCs and research papers, learning Japanese and riding his motorbike.

Current Interests: Kernel Module Programming, WebAssembly, Distributed Storage System, Query Engines, Container Runtime, Schedulers and File Systems.


Advanced Algorithms
Advanced Compilers
Advanced Computer Networks
Advanced Robotics
Advanced Topics in PL Design
Artificial Intelligence: Principles and Techniques
CS Theory Toolkit
Calculus
Computer Graphics
Computer Networking: A Top- Down Approach
Concurrent Programming
Convex Optimization
Cryptography I & II
Data Structures and Algorithms
Database Systems
Discrete Math and Probability Theory
Distributed Systems Engineering
Efficient Algorithms and Intractable Problems
Full Stack Open
Great Ideas in Computer Architecture
High Frequency & Algorithmic trading
Information theory and Entropy
Intro to High-Performance Computing
Introduction to Computational Thinking
Linear Algebra
Mathematics for Computer Science
Nand2Tetris
OCaml Programming: Correct + Efficient + Beautiful
Operating System Engineering
Parallel Computing
Performance Engineering of Software Systems
Probability theory
Programming Languages
Random Processes and Algorithms
OCaml Programming: Correct + Efficient + Beautiful
Operating System Engineering
Parallel Computing
Performance Engineering of Software Systems
Probability theory
Programming Languages
Random Processes and Algorithms
Robotic Manipulation
Safety in Systems Programming
Software Construction
Special Topics in Database Systems
Storage Systems
Structure and I nterpretation of Computer Programs
The Information Theory, Pattern Recognition, and Neural Networks
The Missing Semester of Your CS Education




Hey LinkedIn ! I wanted to post a recap on everything I've done for the last 6 months.

I recently graduated from Amrita Vishwa Vidyapeetham, Coimbatore with a Bachelor of Technology in Electrical and Computer Engineering. I've decided to take a gap year to focus on my graduate applications for Fall 2025, considering both MS and PhD programs (funding required unfortunately). If you're looking for a passionate, driven student for your team, I'd love to connect!

ðŸš¨ I'll be presenting my paper Memspect at the first edition of Innovations In Compiler Technology Workshop (IICT) in Bangalore, India! The session is on Day 2, 03:00PM-03:20PM. See you there !ðŸš¨

In the meantime, I've been busy presenting my work and working on my side-projects. I've also had the privilege of presenting my paper at the ERCICA conference that took place in BGS College of Engineering and Technology, Bangalore. I also got the chance to attend the first meetup of Bengaluru Systems Meetup at the Hasura Office and the July Rustacean meetup at Google's office at Bangalore.

I also officially launched the Arcane Systems Reading Group ( https://lnkd.in/g_PVuGSC ), previously known as Amrita Systems Reading group to some - a collective of systems enthusiasts who explore niche topics like compiler internals, distributed systems, low-latency systems, and performance engineering. This group was first just limited to students of Amrita but after much demand, I've decided to take it seriously and work on it full-time and thus launched a total rebranding where anyone from around the world can join our community of passionate system hackers !

I've been studying books like Introduction to Algorithms by CLRS and Algorithm Design by Ã‰va Tardos. I got participate in Andreas Klingâ€™s Browser Jam where I had some fun times writing a web browser from scratch in Rust and eventually became a serious project for me. I was also part of Summer of Shipping 2024 where after being inspired by Turso and TigerBeetle, I started working on my own edge database in go focused on scaling performance to handle massive multiplayer environments and be deterministic in nature. I also inadvertently join the Ooga Booga Game Devs community and now writing my own game engine in C and Zig. 

I had been interviewing at cool companies such as a supercomputer startup based in SF for but at this moment I'm free for the first time in my life after university and so will be taking my own time to work everything out :) I also may have plans to start my own entrepreneurial venture (something in the likes on video-game infrastructure) 

NOTE: I also launched a very minimal personal website - https://www.varsha.lol. If you're around Bangalore this time, come say hi! I'll be up for a coffee-chat and talk about basically anything !




Education

    Amrita Vishwa VidyapeethamAmrita Vishwa Vidyapeetham
    Bachelor of Technology - B.Tech, Electrical and Computer Engineering 2020 - 2024

Activities and societies: Google Developer Student Club, CodeChef Chapter, Srishti Literary Club, Amrita Center for Entrepreneurship.Activities and societies: Google Developer Student Club, CodeChef Chapter, Srishti Literary Club, Amrita Center for Entrepreneurship.

Mostly self-taught CS outside of classes, did research and clubs on the side, participated in hackathons (HackMIT and Hack the North) thanks to online classes due to COVID and ran 1 (unsuccessful) competitive programming group that now has been pivoted to a independent study group for anyone who wishes to learn systems programming but lacks the resources or support for it.


Design Lead
CodeChef AMRITA CBE Chapter Aug 2021 - Jul 2022 Â· 1 yr

    $ cat role+responsibilities.md
    Designed posters, flyers, and banners along with collaborating with the events management team to promote competitive programming workshops and events. Contributed to overall branding and creative direction of the clubâ€™s social media accounts and unique visual identity for maximum engagement of university students.


Technical Lead
Google Developer Student Clubs - Amrita School of Engineering, Coimbatore Â· Full-time  
Aug 2022- Jul 2023 

        $ cat about_role.md
        Led a team of student developers guiding them in organizing technical workshops and exciting events to build and nurture a vibrant tech community. 

        $ cat responsibilities.md
        Responsibilities includes mentoring students, promoting open-source culture, conducting valuable guest speaker sessions, and collaborating with multiple teams.

 Arcane Systems Reading Group
This study group exists to provide a community around the exploration of niche CS topics, work on truly meaningful stuff, and have fun in the process.

Welcome to Arcane Systems Reading Group!

This study group is about the internals of compilers, programming languages, distributed systems, databases, file formats, internet protocols, operating systems, browsers, emulators, and to build a community around this kind of exploration. You're not expected to have attended previous weeks and expected to adhere to the standards of the Geneva War Convention (optional).

Since we're just starting out, we plan on meeting once a month on a random Sunday afternoon that will be decided in the WhatsApp/Discord GC and work on the planned topics listed here. Feel free to join us during these sessions and decide if this group suits you!
Upcoming Sessions
âŒ˜ OFFICIAL FIRST SESSION ! by vxsha-256

    Zig Internals + Linux Kernel Module Programming
    Zig is a self-hosted, low-level systems programming language which is just a joy to use. We'll be going over the internals of the language and work on writing a Linux kernel module on a x86-64 Ubuntu 24.02 VM.

    Breaking down LevelDB by vxsha-256 LevelDB is a fast key-value storage library written at Google written by the legenedary Jeff Dean himself. We'll be going over the performance and effortlessly clean code which can teach valuable design and programming patterns.


Byte-Sized Workshops

âœ¦ Reviewing DOOM:

Explore DOOM 3 Source Code and its engineering, such as the Quake III arena engine, Binary Space Partitioning, Fast inverse square root algorithm, Lectures from John Carmack & more.

âœ¦ PL & The Web:

The 1 Billion Row Challenge, Exploring Programming Language Runtimes, Crash Course into Low-Latency Systems and Large-Scale Backend Engineering.

âœ¦ Interpreters, Package managers, and Planetary databases:

Go over the Crafting Interpreters Book, Dive into Reproducible builds with Nix, and review Monarch: Googleâ€™s planet-scale in-memory Time Series Database.

âœ¦ Networking guide to the Internet:

Intro to Networking fundamentals, Practical end-to-end Authenticated Encryption, Speedrunning computer networking, and Reading Post-Mortems of Catastrophic Failure in Big Tech Companies.

âœ¦ ML systems & Advanced Hardware (Semiconductors + GPU):

Internals of JAX, ML systems and Compilers, SOTA papers such as Q*, and KANs, a short look into the advancements in semiconductors and computer graphics (via conferences, video game company-specific blog posts, etc).
Scheduled Events
[x] BSOD ( biweekly sessions of development ) :

    BSOD is a one-week intense jam where you implement a cool piece of software from scratch. Writing something from scratch turns theory into practice. You may think you know how a piece of technology works, but until you write it yourself, you truly wouldn't understand it completely.

    ZigFest: 8-day crash course into Zig and Systems Engineering by vxsha-256

    Designing SIMD Algorithm from Scratch, Building your own TCP/IP, Modern SOTA in-memory cache implementation, and Rebuilding Redis from the ground up.

    Deployment from Scratch: over-engineering a website as of 2024 by vxsha-256

    Learn how how web-apps work in production by working on our very own website - ASRG.tech! Learn the fundamentals for setting up servers and provisioning databases while gaining real-life experience.

    OS-Dev: 4-week speedrun of building a mini-os from scratch with Rust and C by vxsha-256

    Implementing a kernel from scratch, exploring the C run-time model, concurrency and hypervisors, and much more hell has to offer !

    UNIX Jam: 1-week festival of intense systems programming and high-performance optimizations by vxsha-256

    Deep look into io_uring and eBPF, recreate coreutils with your favorite language, distributed system challenges, writing x86 assembly for FFMPEG and so much more fun stuff.

    Compiler Construction: 10-day jam of building modern compilers by vxsha-256

    SOTA compiler optimization techniques, design experimental features, work on your own virtual machine around it, learn from other more established compilers.

[x] OCaml My Caml :

    A week-long hacking retreat to work on a variety of OCaml projects, including but not limited to the compiler, concurrency libraries, platform tooling, and benchmarking. Dive into functional programming and learn to appreciate actual ML languages instead of drooling over a whitepaper like Haskell.

[x] Open Session :

    Free-for-all kind of event where people give talks, get help on their homework/projects and work on random stuff. This is open to all and is an excellent way to integrate into the community. You can even just sit and watch what each member is doing without necessarily needing to pair-program.



Hari Varsha
2SpaceMasterRace
for the glory of Vim & GNU/Linux.


2SpaceMasterRace/README.md
About Me :

Hi ! I'm Hari Varsha, better known as vxsha-256 / nanodijkstra around the internet.

I like to work on cool stuff such as storage engines, distributed systems, machine learning infrastructure & such. I'm a big fan of optimizing developer workflows, craft blazingly-fast projects ( that just work ) and understand computer systems deeper to unlock the secrets of the universe.

Previously Summer Intern @ UCSC ( Go Slugs! ) and now an upcoming grad school student ( hopefully ) specializing in systems programming.

Based in Bengaluru, India.

I'm a fresh Electrical and Computer Engineering grad. I've hacked around everything fun from large-language models to embedded microcontrollers and worked as a Summer Research Intern @ UCSC (Go Slugs!) and as a lab member for over a year. I specialize in building the next-generation serverless platforms and machine learning systems.

Over the years, Iâ€™ve become deeply entrenched in the world of deep systems programming, AI research, game engine development, and cloud infrastructure. Apart from intense development, I like consuming comics like XKCD and SMBC, reading Hacker News threads, and essays from cool people like Paul Graham & Joel Spolsky.

I lead the Arcane Systems Reading Group, a collective of systems nerds who explore niche topics like compilers, operating systems, distributed systems, low-latency systems, and performance engineering. My career goals can essentially be boiled down to producing the same influence as YEAT, DVRST, Playboi Carti, and Kendrick Lamar but for computer science as a whole.

I'm having a great time reading source code of **Unix-based Kernels** and dissecting **Kernel-Level anti-cheats**, implementing research papers like the **Raft protocol** and watching conferences such as **CPPcon and Zig Showtime**. I plan to set up substack and start streaming development on Twitch soon in the future. My hobbies include amateur game development, reading RFCs and learning Japanese.

I've also been deep diving into **internals of Zig programming language**, writing my own **Linux Kernel Module** in C and Zig, and experimenting on **Hash Tables** to learn them on a deeper level. I'm trying to build a habit of reading technical books and I've been enjoying **Designing Data-Intensive Applications** by Martin Kleppmann & **Algorithm Design** by Ã‰va Tardos.

## Ongoing Projects

My projects reflect my interests in machine learning infrastructure, hardware engineering, video-game development, and systems-level programming. Here are some projects Iâ€™m currently working on:

- **Memspect** [C, Rust, LLVM]: A cool static analysis framework for real-world C codebases that focuses on fast and accurate memory debugging. Gained arcane knowledge of compiler internals in the process. Started off as a final-year project and was presented at two separate conferences.
- **ART.tv** [Typescript, Go]: Iâ€™ve always loved films, so it only makes sense that I build a streaming platform for indie movies. Inspired by Mubi and Twitch, this is my full-stack project where I enable creators to showcase their arthouse and foreign language films to the world.
- **Cherenkov** [Rust, Go]: After participating in Andreas Klingâ€™s Browser Jam, I decided to build a minimal, full-fledged vim-based web browser. This is more of a toy project to understand browser engineering.
- **Loveless** [Go, Zig]: A cool edge database that focuses on auto-scaling and performance to handle massive multiplayer environments. Started building it as part of Summer of Shipping 2024 after being inspired by Tiger Beetle and Turso.
- **Kaze Switch** [Rust, OCaml]: Emulators have always been a fascination of mine and unfortunately most switch emulators struggle to run on low-end PCs. So Iâ€™m building my own lightning fast Nintendo Switch emulator with portability and networked multiplayer in mind.
- **Terra** [C, Typescript]: Working on my own MMORPG as part of the Ooga Booga Game Devs community, where a group of game devs come together to ship great games from scratch, while mastering the ancient art of Caveman Programming.
- **Axogig** [Python, C++, CUDA]: Building a high-performance distributed training framework to train neural nets across GPU clusters seamlessly. Started off as a project for Buildspaceâ€™s Nights & Weekends Season 5 and just kept continuing to work on it.

**Future Projects** include an experimental file-system to compete with ZFS & BTRFS, a GPU-aware scheduler for serverless platforms, MapReduce from scratch, context-sensitive search-engine for metadata & logs, tiny open-source machine learning compiler, library containing state-of-the-art algorithms for distributed deep learning, inference engine from scratch, building my own network stack for p2p file sharing and custom GPU orchestrator for managing H100 clusters.

## Career Interests

I enjoy **solving novel systems** problems and prefer **building reliable tools** that just work and stand the test of time. This was inspired by using actually good software that never lets me down and covers all of my uses such as **7zip, Vim, Curl, i3**, etc. I really appreciate and value good documentation, especially ones from **SpaCy, Emacs,** and **Lua.**

My experience has allowed me to **prioritize ownership** and **autonomy** over my work. I deeply care about my craft and tend to have healthy debates over various programming topics, especially with senior engineers. My engineering philosophy is heavily inspired by **Andrew Kelley's Practical Data Oriented Design** with some elements of Procedural and Functional programming sprinkled in. Here are some of my professional interests in greater detail:

#### âœ¦ Supercomputers, Distributed Computing & Systems for Fun and Profit

One of my primary interests lies in designing and building novel, high-performance systems for machine learning, particularly at supercomputing scale. As a humble systems engineer, I'd kill to work on interesting projects like optimizing container runtimes, implementing distributed file systems, and building large-scale data processing applications like Apache Hadoop.  
Previous experience include exploring operating system design and HPC network architectures, hacking high performance storage systems such as Weka and Ceph, designing custom load-balancing algorithm to optimize serving efficiency, breaking the CUDA compiler, and performance enhancing virtual machines.

#### âœ¦ Writing Custom GPU Kernels for Machine Learning Systems

Iâ€™ve always had a deep fascination with GPUs ever since I played Crysis 3 as a kid. Now, I explore ways of writing my own high-performance GPU/CPU compute kernels for fun and that led me down a rabbit hole of optimizing CUDA kernels for TPUs, GPUs & AWS Trainium. I'd like to see how far I can push modern-day GPUs by studying the performance characteristics of various GPU architectures and optimizing compilers to leverage their hardware features like tensor cores.

#### âœ¦ Managing Infrastructure and Handling SEV-1 for Breakfast

I take great pleasure in deploying on bare-metal machines and building tooling for infrastructure engineers. As a proud supporter of self-host movement, I have spent a good amount of time on private networking and cloud-native observability tools. I like being experimental with my work - e.g. integrating WebAssembly to avoid long cold starts and over-provisioning.  
I'm not afraid to delve one level deeper using tools like eBPF to monitor and mitigate excessive CPU usage, instrumenting the Linux scheduler with ftrace and perfetto, analyzing request latency using sampling profilers like gprof, trying and failing to configure Kubernetes for optimal workload performance, using pprof to optimize Go code & maintain top performance across services and more spells under my sleeve.

#### âœ¦ Hacking Hardware Architectures & Performance Engineering

Building robust, low-latency hardware & applications to serve billions of users has always been a career goal of mine. I would actually love to put my EE degree in use particularly on ASIC chip design and developing microprocessor architecture. I'd seize any opportunity on tearing down ML accelerators such as Googleâ€™s TPU & Groq's LPU and consumer hardware like Apple's AirTag.  
I also have a good amount of battle scars in performance and backend engineering, especially in debugging kernel-level network latency spikes in containers, tuning JVM Garbage collection & developing GPU Task Schedulers, and implementing low-latency high-throughput sampling for large language models. Other strong interests include orchestration engines, block storage systems and compute services.

#### âœ¦ Crafting Interactions with Love & Creative Frontend Engineering

As an interactive designer and creative front-end engineer, the web is just another canvas for me to create art and express stories. I am particularly fascinated by the challenge of delivering beautifully designed websites like those in Awwwards and Godly. Iâ€™m fortunate enough to upskill myself in various aspects of design, from typographic layouts to implementing complex web specs to get things done.  
I have experience in building front-end infrastructure tooling and thrive in startupy backgrounds where ambiguity is the norm. I excel in building complex and gorgeous products, and have a high degree of empathy for user-experience, accessibility, and ownership. Taking products from 0 â†’ 1 and designing high-quality, joy-inducing, beautiful interfaces that make a real impact are my strong suits.


Designing_Data_lntensive_Applications.pdf
Dive Into Systems_ A Gentle In - Suzanne J. Matthews & Tia Newh_35413.pdf
Fluent React Build Fast, Performant, and Intuitive Web Applications (Tejas Kumar) (Ze
Grokking Data Structures (Marcello La Rocca) (Z-Libray).pdf
How_to_make_a_Game_Boy_emulator_keep_marriage_and_have_kids.pdf
Kotlin in Action 2ed 2024 (Sebastian Aigner, Roman Elizarov etc.) (Z-Library).pdf
Learn C++ by Example (Frances Buontempo) (Z-Library).pdf
Learn Git - The Full Course [rH3zE7VllMs].mp4
oh-shit-git-zine.pdf
Operating_Systems_From_0_to_1 .pdf
operating_systems_three_easy_pieces.pdf
base_2024.pdf
Principles of Algorithmic Problem Solving.pdf
raft.pdf
React in Depth (Morten Barklund) (Z-Library).pdf
The GNU Make Book.pdf
The_Joy_of_Cryptography.pdf
Thinking_Low_Level_Writing_High_Level_Write_Great_Code_Volume.pdf
Writing a C Compiler Build a Real Programming Language From Scratch (Nora Sandlm
Writing_a_C_Compiler_Early_Access.pdf


[Tutorial] A Way to Practice Competitive Programming.pdf
Algorithm-Design-Manual.pdf
Algorithms-JeffE.pdf
bookmarks.html
Build a Frontend Web Framework (From Scratch) (Ã…ngel Sola Orbaiceta) (Z-Library).pm
Competitive Programming 4 - Book 2 (Steven Halim, Felix Halim, Suhendry EffendyL
cp4-I.pdf
cp-geo.pdf
Deep Learning with JAX (Grigory Sapunov) (Z-Library).pdf
Designing_Data_lntensive_Applications.pdf
Dive Into Systems_ A Gentle In - Suzanne J. Matthews & Tia Newh_35413.pdf
Fluent React Build Fast, Performant, and Intuitive Web Applications (Tejas Kumar) (Z-L
GroW(ing Data Structures (Marcello La Rocca) (Z-Library).pdf
Grokking_Algorithms_lllustrated_guide_for_programmers_and_other_curious_peope
How_to_make_a_Game_Boy_emulator_keep_marriage_and_have_kids.pdf
Khan_Grokking_MEAP_ch1_V05.pdf
Kotlin in Action 2ed 2024 (Sebastian Aigner, Roman Elizarov etc.) (Z-Library).pdf
Learn C++ by Example (Frances Buontempo) (Z-Library).pdf

Frontend Masters - Blazingly Fast JavaScript
Frontend Masters - Build Go Apps That Scale on AWS
Frontend Masters
- HTMX & Go
FrontendMasters - Developer Productivity
FrontendMasters - Everything You'll Need to Know About Git
FrontendMasters - VIM Fundamentals
Polyglot Programming TypeScript, Go, & Rust
prjkt design + awwwards"â€¢'
The Last Algorithms Course You'll Need
The Last Algorithms Course You'll Want (Part 2)
TLE ELIMINATORS

Building a Static Type-Inferring Compiler
Spend a full day learning to build a static type-checking compiler with Richard Feldman!
Key Takeaways

By participating along with us in the workshop, you'll learn:

    Understand how type checking and type inference work
    Learn how compilers can statically detect naming errors
    See how to build compiler-related tools like a code formatter
    Learn how a compiler can use static types to generate efficient machine code

Is This Workshop for Me?

This course is for experienced programmers. It uses (very basic) JavaScript as the language for implementing the compiler, so if you want to do the exercises, youâ€™ll need to be able to write JS. The course also starts with a compiler that turns source code into data structures, so although the course doesnâ€™t require that you know how to do that, it also wonâ€™t be covering how to do it.
Workshop Details

In this course, youâ€™ll learn how to build a static type-checker and binary machine code generator! Along the way, youâ€™ll learn how to statically detect naming errors, as well as the basics of making a code formatter. This course doesnâ€™t cover how source code gets parsed, or how interpreters work, but other courses cover those concepts (such as the â€œBuilding Your Own Programming Languageâ€ course).
Any Prerequisites?

    Significant programming experience (in any language)
    Knowing how to write JavaScript on a basic level, because the examples and exercises use JavaScript.

Daily Schedule

    9:30AM
    Introduction
    10:00AM
    Traversing the AST
    10:30AM
    Name Resolution
    11:30AM
    Type Inference
    12:00PM
    Lunch
    1:00PM
    Constraint Generation
    2:00PM
    Type Solving
    3:00PM
    Machine code generation
    4:00PM
    Wrap-up




I wrote a book on building distributed services with Go from scratch: Distributed Services with Go: Your Guide to Reliable, Scalable, and Maintainable Systems. It's available in beta now, full release will be out in a month or so.

    Go's standard library was suited to networking services because it came out of Google. Then it was a cycle of open source distributed projects using Go, which created nice distributed computing libraries, which made it easier for other distributed projects, etc.

    Lots of projects: Kubernetes - orchestrator, Consul - distributed k/kv store, Nomad - scheduler, etc. See this list for more projects.



Consul and Nomad use Serf for their clustering as well that helps with distributed services. Hashicorp has some great source code but it's pretty technical. It's how they make money, as that's the enterprise features.


Read the Go and the C++ spec



Designing Data-Intensive Applications seems to be the industry standard, but make it Go specific.

 The MIT distributed systems course is pretty good and they use go as a teaching language, and it's taught by two big legends in the field Nancy Lynch (who literally wrote THE Book on distributed algorithms) and Robert Morris (yes the guy who wrote the first virus he's a professor emiritus )

Lecture Tapes
https://www.youtube.com/watch?v=hBWfjkGKRas&list=PLkcQbKbegkMqiWf7nF8apfMRL4P4sw8UL&index=1
Lecture Notes and Selected Papers
http://nil.csail.mit.edu/6.824/2017/schedule.html
I know that this isn't what you're looking to hear, but like looking when looking for courses on computer science principals, you shouldn't have a specific language as part of your criteria, most distributed systems courses are basically lectures explaining seminal papers, explaining fundamentals like CAP, and then you do projects like implementing RAFT or Memcached.

Honestly the path to learning is just read papers and implement shit, have it fail in some way, learn your lesson, repeat.
These are really noob friendly introductions to the basics that can get you caught up quicker than the book designing data intensive applications.

http://book.mixu.net/distsys/

https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/

Miscellaneous Resources

The big seminal paper on crdts .

https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf
Yale Course Lecture notes (I use it as a briefer, easier to traverse, and more modern reference book, other people use Lynch's book)

http://cs-www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf

SWIM (a simple scaleable gossip protocol)

https://www.brianstorti.com/swim/

Omega (Kubernetes is basically omega made user friendly and domain specific)

https://storage.googleapis.com/pub-tools-public-publication-data/pdf/41684.pdf

Mesos (a cluster scheduler like kubernetes that uses a different model)

https://people.eecs.berkeley.edu/~alig/papers/mesos.pdf

A good overview on what goes into implementing highly performant clients, (retry policies, load balancing algorithms, and connection pooling).

https://twitter.github.io/finagle/guide/Clients.html#load-balancing

Go Code Bases

Implements Swim
https://github.com/hashicorp/memberlist

Implements Raft

https://github.com/hashicorp/raft

An implementation of Google's Omega Scheduler

https://github.com/hashicorp/nomad

Consistent Hashing (Dynamo and Elastic Search use this to shard data)
https://github.com/lafikl/consistent

A library for the major load balancing algorithms
https://github.com/lafikl/liblb

Apart from the resources on theory, in production your metrics and logging game has to be on point, otherwise you're just a blind elf going through multiple layers of abstraction. 



Look at the papers on the link below for further education on Distributed Systems and try to search topics a little bit more defined, like gRPC in Go, or PubSub with RabbitMQ in Go, or Stream through Kafka in Go, etc.

https://columbia.github.io/ds2-class/




LevelsDB +  Spotify Wrapped + Jujutsu VCS


Buy the "Distributed Services with Go: Your Guide to Reliable, Scalable, and Maintainable Systems " book, in the preface it talks about DDIA, and notes that it is coming from the academic viewpoint, but the practical in-the-trenches experience comes from actually building systems that explore these concepts.

> When I began learning how to build distributed services, I found the existing resources to be of two extremes:

> â€¢ Concrete codeâ€”distributed services are large, complex projects, and the prominent ones have had teams working on them for years. The layout of these projects, their technical debt, and their spaghetti code bury the ideas youâ€™re interested in, which means you have to dig them out. At best, learning from code is inefficient. Plus thereâ€™s the risk that you may uncover outdated and irrelevant techniques that youâ€™re better off avoiding in your own projects.

> â€¢ Abstract papers and booksâ€”papers and books like Designing Data- Intensive Applications by Martin Kleppmann1 describe how the data structures and algorithms behind distributed services work but cover them as discrete ideas, which means youâ€™re left on your own to connect them before you can apply them in a project. These two extremes leave a chasm for you to cross. I wanted a resource that held my hand and taught me how to build a distributed serviceâ€”a resource that explained the big ideas behind distributed services and then showed me how to make something of them.

Atleast for me, I can't remmeber anything unless I _do_ it , e.g. program it. SO I read DDIA, and remember 2% usuall. This book on the otherhand, after typing out the examples, I can go through it in my mind easily and regurgitate concepts introduced in each chapter.

i really hope the author writes another book because he has a great knack at breaking down the complex topics into nice bitesize code modules and explanations

Just with reading I have the same as you: no retention. Or only a scattering of info, enough to misremember and look a fool.

Your method of learning is likely different, mine is reading/watching + doing.

I usually watch something, pause to mimick/copy what they did and then repeat until done. By "copy" I mean: type out manually.

I will also debug along the way to see if something is already working/giving a result. If it broke (for a variety of reasons, like: not there yet in the lesson) I will try to find out what comes next.

This makes exercises really interactive. By triggering multiple senses (seeing, typing (touch), hearing) you already have a better chance to remember. By doing, debugging and attempting to understand while the lesson is not there yet, I gain deeper understandings of patterns, frameworks, libraries and principles than I would if I only read it.

To come back to the beginning: your method of learning is likely different. So, find your own way, then find content (books, podcasts, videos, newspapers, etc) to help you learn your way.

Learning to learn is the hardest part imho. Don't be afraid to adjust your way of learning with new insights either.

I used to be book+do. Now it's mostly watch/hear + do + debug.

MIT 6.824: Distributed Systems - YouTube
https://www.youtube.com/channel/UC_7WrbZTCODu1o_kfUMq88g

https://www.andrew.cmu.edu/course/15-440/

do project courses

**http://web.mit.edu/6.033/www/ + Dive into systems +CSAPP + https://news.ycombinator.com/item?id=25272229 + https://pdos.csail.mit.edu/6.824/ + nanodijkstra.tv ** 

https://github.com/Developer-Y/cs-video-courses




This is the advice I followed (worked out great), and I gave to my brother (also worked out great). It comes down to 3 steps:
* Have personal projects you use to demonstrate the ability to learn new things. For example, do you want to learn how networking works? No better way than making a simple SFML C++ chatbox or even a simple game that uses TCP ports to communicate. Another example, do you want to learn how Docker works? Dockerize the same networking application from earlier. You get the point. Each project should allow you to learn something, and be contained for that topic. Also keep all of them as public repositories on GitHub -- I've had more interviewers look at mine than not. Plus if you start now, you will be proud of your GitHub page when you graduate.

* Network. This is extremely important. Start early, start now. Make friends with everyone in your program -- you don't know who will help you get an internship or a job. Go to every single event, talk to recruiters, people. Be extroverted even if you aren't. Cold applying to internships and jobs is peeing against a strong wind, hoping you won't get splashed. You always need someone to get your foot in the door.

* Finally: practice LeetCode once a week. Learn everything that goes into technical interviews. Because if you put all of that hard work in, you will get some interviews for internships in college. You don't want to whiff because you aren't prepared. Unfortunately, and this is my opinion, technical interviews are very controversial. They don't reflect an engineer's ability to actually work. They reflect how much practice and memorization of LeetCode problems you have done. So work on them.





Probably build a compiler, os, some kind of distributed system and a database engine. 


Read CLRS and SICP sooner

 1st year:
    Install Linux
    Learn C/ C++
    Start Competitive Programming
	    Practice for cpp and try your luck at ICPC (Olympics for coding) or any other coding contests. Don't stress out but have fun in your own way. 
	Do Opensource
		Try making open source contributions and test your skills at GSoC. It mostly comes during Jan but have a basic idea of Open source before that. 
	Competitions
		Participate in hackathons a lot and network with a lot of people. Make a LinkedIn profile and stay active. If you're into cybersecurity stuff - try CTFs and Foss. 


 Concurrency is an area where universities shine; take that if it's offered.

Ai, machine learning, natural language processing, cryptography should all be high quality since there is a lot of math involve and math is where these schools excel.

Database internals, operating system internals, low-level networking should be good picks. 

- There is a lot of pressure to be an engineer if you did well in school (math/science especially). Make sure you actually enjoy it. Plenty of people burnout way before graduation because they don't actually like it.
    
- You have time. Stop trying to learn everything all the time. Pacing is a super underrated skill, especially among young people
    
- Make lots of friends. Getting a 90 on an exam that you studied for with friends pays off in life skills way more than getting a 100 by studying on your own. Be a people person.
    
- Think of SWE as a skill, not a field. Use it to do things you enjoy in a field you enjoy. Most folks don't like SWE enough to "specialize" in SWE or CS.
    
- Get off this sub-reddit. It's pretty damaging to young engineers.



Most importantly:

    make friends early, the first two weeks are CRUCIAL. A good group helps you stay up to date on assignments and tests.

    get internships as early as possible. Don't wait for X semesters because you don't feel ready. Apply right away. You learn most at internships.

    consistency beats all nighters every time.

    don't forget to enjoy yourself every once in a while, but try to go outside or play sports instead of playing video games.

    join hackathons! They're fun and you learn a lot and get to know awesome people.

And don't forget: the most frustrating problems are often the ones where you learn the most. I believe in some kind of "education karma". If you invest time, you WILL get a return on that investment, even if you don't see it right away.

I'm going to go against what the majority of people have said here at this point in time. I am currently undertaking a Masters and I love it.

Each subject is like a small window into a deep research area.

I've become aware of TLA+, Paxos, Raft, distributed algorithms in general, branchless programming, how to implement various compiler optimizations, etc. I'm okay within these fields, I still have a lot to learn, as I said before the subjects have only been windows into much deeper fields/topics.

I'm not saying that you wont eventually come across these things without a Masters but it helps accelerate the time it takes.

I can gladly say that my programming skills have increased substantially as a result of my Masters.

For you, I cannot give any specific advice unfortunately, since I do not have that much knowledge on GPU programming. I know enough that that field is quite math heavy.

working at Jane Street on the OCaml compiler 

I can show that you don't need to finish a PhD in AI to do research and create AI to solve problems people have never before successfully approached. I've done it myself (though unfortunately most of it is locked behind a walled garden of IP).

If this is a course you're interested in, here's what I suggest.

1) Read up on AI breadth first and shallowly. Focus more on machine learning, search, filtering, and so forth, than heavier (and less successful) topics such as knowledge systems and computer vision.

2) Go through a list of startups that you like, use, or admire. Imagine the simplest cool/good/useful thing the startup could do with a cute little algorithm.

3) Develop the basic idea for it, contact the company, say you'd like to hack on it for cheap.

4) Kill the problem.

5) Use that startup as a reference. Find another one, but this time, ask that you can publish the method.

6) Repeat. Blog about your conquests. Explain how to replicate and extend your results. Eventually, focus on a bigger project to tackle. If your interests align with a research program at a university, consider entering the PhD program then. With this behind you, you'll probably get in anywhere.

Technical side of things: Pick up an open source project that you like and start contributing. Get involved in competitions through the university if you can, there should be plenty. Learn to work as part of the team, try to affect the team in a positive way, learn to accept others. "Google summer of code" is something I would consider at this stage.

* Open-ended puzzle/system design games (SpaceChem, EXAPUNKS, Magnum Opus, TIS-100, Factorio, Shapez.io, Mindustry)
* * Sedgewick & Wayne CS & DS/Algos books & accompanying Coursera courses 


2. Data Structures and Algorithms is useful, how useful depends on your goals. If you want to make the big bucks you should aim to be fluent in at least a textbook's worth of material. If you don't feel the need to aim for the top, you can get away with less. I would start with Skienna: [https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena...](https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202)

If you really want to be a master, you can then go for CLRS: [https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press...](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=pd_lpo_3?pd_rd_i=0262033844&psc=1)

3. This depends on your goals. If you're aiming to be a top engineer now's one of your few chances to really focus in on lower level system stuff: Operating Systems, Networking, Compilers, or Databases. If you want a decent job fast of college, focus on data structures and algorithms and start trying to deploy code on something like digital ocean. That said you probably also want to do: [https://missing.csail.mit.edu/](https://missing.csail.mit.edu/)

General advice: Dive deep, understanding a few things really well is better than understanding many things shallowly (you will retain more info over time).

A mistake many people make when reading textbooks is to guess what words mean. In technical texts this usually leads to misunderstandings and ultimately a slower learning process. Take the time to understand the words even if it takes hours (imminent deadlines notwithstanding), you will go faster. (I once took a month to get through a single page of a textbook because it had so many new words and concepts).

Start using version control (preferably git). Try to at least every hour if you have new code.

Try to start writing well structured code now. You probably won't do a great job at first but by trying earlier you'll do better.


ship a 3d mmo game by the time you graduate.

it will give you a challenging context to apply everything you are learning.

bonus points for linux and wickedengine.

Learn how to use your debugger. People will tell you things like "If you use unit tests, you never have to use the debugger!" but it's nonsense. When one of your tests break, you have to dig in and find out why it broke, and that means debugging. Plus a lot of things can't be reasonably tested in unit tests.

Take a class on ethics. Most companies hiring CS majors today are sorely lacking in ethics and it would be good to know ahead of time which are which.

Learn how to ask questions to get good answers. In particular, learn how to write up an MCVE - Minimal, Complete, Verifiable Example [0]. The better the quality of the question, the better the quality of the answer. This is really hard when starting out using a technology you know nothing about. In those cases, describing what you're trying to do, what approach you're taking, and why you think that approach is useful will get you to answers about how to do it correctly more quickly.

Don't spend too much time on HackerNews. The articles posted here tend to attract a certain crowd with a certain viewpoint on any given subject and it's a bit of an echo-chamber.

[0] [https://stackoverflow.com/help/minimal-reproducible-example](https://stackoverflow.com/help/minimal-reproducible-example)


One thing that helped me a lot was getting involved in competitive programming. Back then it was just the ACM contests but now there are multiple sites like Topcoder, Codekatas, Codewars, etc. Working through different levels of challenges in different languages helps push your language and algorithm knowledge. Reading other people's solutions is also a huge help.

Build up formal foundations eg. complexity, runtimes, grammars, state machines and proofing (use something like coq to get used to it). Learn an imperative (c), a functional (haskell), a declarative (answer set programming or prolog) and an oop language (java). if you understand them you can easily switch between languages. do math and ignore ai because it's just simple math. Do something with parallel computing eg use MPI, OpenMP or computations on the graphic card. keep coding.


Take courses across a breadth of areas in Computer Science, even if you think you don't (or won't) enjoy them much. Don't take up courses only in areas you enjoy (say, Networking) and have no concrete knowledge of areas you think you don't really like (say, Graphics) - Undergrad in my opinion is ideal for building up breadth of Computer Science knowledge. You can always focus on specific areas in grad school or when you start working.


- Dig deep: computer architecture/organization, assembly, Linux from Scratch, source code of OSes/tools, etc. And, there's more out there than just FOSS; some very useful tools aren't new, OSS or popular. Get proficient at debugging tools.


- Push your comfort-zone, often. Do hard things: write a C compiler, design a pipelined/microcoded/branch-predicting MICMAC processor, write a kernel module, write a 3D graphics engine, and so on.

- Master the fundamental concepts, data structures and algorithms.

Ask HN: What are some of the best technical talks you've heard? | Hacker News
https://news.ycombinator.com/item?id=18217762

Ask HN: What are the best textbooks in your field of expertise? | Hacker News
https://news.ycombinator.com/item?id=18104814


[ ]  Watch sovietwomble videos essays ++ Read upon Golang (for compiler tooling), TypeScript, PureScript, SolidJS, Bun, SQLite, gRPC.
[ ] Developer Tooling with primeagen x learning compilers from YouTube  x Stalk the founder and the company, 


## Part 4: Own your Aesthetic





[ ] Go in-depth of Projects

	[ ] special passion in local-first software, realtime databases, multiplayer apps, distributed systems, CRDTs, storage engines, amateur game development, experimenting with Nix, kernel programming, webassembly, distributed storage system, query engines, container runtime, schedulers,  large-language models, embedded microcontrollers, virtualization, concurrency, deep systems programming, AI research, game engine development, cloud-native infrastructure, compiler internals, low-latency systems, hardware engineering, performance engineering , message queues,   operating systems, and machine learning infrastructure 
	[ ] Currently working on a linux kernel module [brainstorm something good], reading up on Unix-based Kernels, dissecting Kernel-Level anti-cheats, and implementing research papers like the Raft protocol in Go, ,
	[ ] Project: LOVELESS
		[ ] Background: I initially wanted to build an edge database like Turso but genuinely felt like I had no idea what I was doing. I've also decided to make use of @TigerBeetleDB and @AntithesisHQ features [ watch the systems distributed talk of anti-thesis and andrew kelley and bryan cantill one]
		[ ] Project: LOVELESS:
			[ ] I've also collected an insane collection of conference talks and blog posts and other stuff from @TigerBeetleDB + I've also made use of the fantastic resources in @eatonphil's discord server to learn databases deeply and construct a mini roadmap.
			[ ] Read books like DDIA and Database Internals
			[ ] Building an edge database from first principles like @tursodatabase over the summer. I'll be learning a lot about databases, computer networks, and distributed systems while shipping features no one asked for.
			[ ] Distributed Database for MMOs | Zig, Go, Charm June 2024
				â€¢ Built a high-performance edge database optimized for multiplayer game environments, implementing custom auto-scaling capabilities and efficient data replication across edge nodes.
				â€¢  Engineered unified caching system with custom eviction algorithms in Zig, reducing memory overhead while maintaining consistent query performance.
				â€¢ Built developer-friendly terminal dashboard using Charm, enabling real-time monitoring of node health, replication status, and memory utilization across edge deployments.
				â€¢ Distributed Database to help shape the future of our open-source, Google Zanzibar-inspired database, focusing on low-latency query optimization, refining database architecture, and ensuring the system is robust and reliable for large-scale, mission-critical applications.
				â€¢ Drive Optimization efforts by gathering statistics, refining query planning, and implementing materialized views and incremental view maintenance (IVM).
				â€¢ Apply indexing, partitioning, and caching strategies to improve query efficiency and overall database performance ++ TUM DB workshops & yt channel
		[ ] Fast Container Runtime for ML Workloads | Rust, C++ April 2024
				â€¢ Built lightweight container runtime for ML development environments, enabling quick switching between frameworks (PyTorch, TensorFlow) with faster setup time.
				â€¢ Developed custom filesystem caching layer in C++, enabling efficient image layer stacking and leveraged eBPF to reduce syscall overhead during container initialization.
				â€¢ Implemented container orchestration system supporting dynamic resource allocation, achieving sub-second cold starts for containers through lazy loading techniques.
				â€¢ I was the principal architect behind Modal's container runtime, the high-performance system written in Rust that runs Modal functions. Its stability let Modal scale from 50 CPUs / 2 GPUs to 100,000 CPUs / 5,000 GPUs, all while adding new features to the platform.

[ ] Get good at socializing
	 [ ] Future plans: Competitive programming, Grad School, Meeting more senior engineers and cool people in systems, Get into Streaming on Twitch, Work on my entrepreneurial venture something related to video-game infra tech -- refer that video game startup horror story on twitch, participate in AI hackathons to CTFs and Game Jams, Working on my own MMORPG in C and Go as part of the Ooga Booga Game Devs community and build my own lightning fast Nintendo Switch emulator with portability and networked multiplayer
	 
